## ArrayList和LinkedList的区别

ArrayList：基于动态数组，在内存中占用一片连续的存储空间，适合下标访问（随机访问）。扩容机制：因为数组长度固定，超出长度存储数据时选需要新建数组，然后将老数组的数据拷贝到新数组，如果不是尾部插入数据还会涉及到元素移动（把所有元素往后移动一位，插入新元素）。如果合理指定容量可以提升性能，因为不会再新建数组，使用尾插法并指定初始容量可以极大提升性能，甚至超过LinkedList。

LinkedList：基于链表，可以存储在分散的内容空间中，适合做数据插入和删除操作，不适合查询，因为需要逐一遍历。遍历LinkedList必须使用iterator，不能使用for循环，因为每次for循环体内通过get()方法取得某一元素时都需要对List重新进行遍历，性能消耗极大。

## HashMap和HashTable的区别

1. HashMap方法没有synchronized修饰，线程不安全，HashTable线程安全。
2. HashMap允许key和value为null，HashTable不允许。

## 线程的生命周期

线程有五种状态：创建、就绪、运行、阻塞、死亡。

创建：当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态。

就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时已具备了运行的条件，等待被分配到CPU资源。

运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线程的操作和功能。

阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态。

死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束。

阻塞状态分为三种：

**等待阻塞**：运行的线程执行wait方法，该线程会释放占用的所有资源，JVM会把该线程刚入“等待池”中。进入这个状态后，是不能主动唤醒的，必须依靠其他线程调用notify活notifyAll方法才能被唤醒，wait是Object类的方法。

**同步阻塞**：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中。

**其他阻塞**：运行的线程执行sleep或join方法，或者发出了IO请求时，JVM会把该线程设置为阻塞状态。当sleep状态超时，join等待线程终止或者超时，或者IO处理完毕时，线程重新转入就绪状态。sleep是Thread类的方法。

## sleep，wait，join，yield

**锁池**：所有需要竞争同步锁的线程都会放在锁池当中，比如当前对象的锁已经被其中一个线程得到，则其他线程需要在这个锁池进行等待。当前面的线程释放同步锁后，锁池中的线程会继续竞争同步锁，竞争到同步锁的线程会进入就绪队列等待CPU分配资源。

**等待池**：当我们调用wait方法后，线程会放到等待池中，等待池中的线程不会去竞争同步锁。只有调用了notify或notifyAll方法后，等待池的线程才会开始去竞争同步锁。notify是随机唤醒一个线程放到锁池，notifyAll是唤醒所有线程进入到锁池。

1. sleep是Thread类的静态本地方法，wait则是Object类的本地方法。
2. sleep方法不会释放锁，但wait方法会释放，而且会加入到等待池中。
3. sleep不需要被唤醒（睡眠之后退出阻塞），但wait需要
4. sleep一般用于当前线程休眠，或者轮巡暂停操作，wait则多用于线程之间的通信。
5. ……

yield执行后线程直接进入就绪状态，马上释放了CPU的执行权，但是依然保留了CPU的执行资格，所以有可能还会马上获得CPU资源。

join执行后线程进入阻塞状态，例如在线程B中调用线程A的join，那线程B会进入到阻塞队列，知道线程A结束或中断线程。
例如，在main方法主线程中调用了线程A的join方法，那么主线程则会停止执行（阻塞），直到线程A执行完毕，主线程才会继续往下执行。

## Thread和Runnable

## 为什么使用线程池，参数解释

**降低资源消耗**：提高线程利用率，降低创建和销毁线程的消耗。

**提高响应速度**：任务来了，直接有线程可用可执行，而不是先创建线程。

**提高线程的可管理性**：线程是稀缺资源，使用线程池可以统一分配调优监控。

- **corePoolSize**：代表常驻核心线程数，也就是正常情况下创建工作的线程数，这些线程创建后并不会消除，而是一种常驻线程。

- **maximumPoolSize**：一个任务被提交到线程池以后，首先会找有没有空闲存活线程，如果有则直接将任务交给这个空闲线程来执行，如果没有则会放到工作队列中，如果工作队列满了，才会创建一个新线程。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个最大限制就是maximumPoolSize。

- **keepAliveTime**：多余的空闲线程存活时间。如果一个线程处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间（keepAliveTime）后，这个空闲线程会被销毁。

- **unit**：keepAliveTime的单位。

- **workQueue**：用来存放待执行的任务，假设我们现在核心线程都已被使用，还有任务进来则全部放入队列，直到整个队列被放满但任务还在持续进入则会开始创建新的线程。JDK中提供了四种工作队列：

  ​	ArrayBlockingQueue：基于数组的有界阻塞队列，按FIFO排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源	耗尽问题。当线程池中线程数量达到corePoolSize后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已	经是满的，则创建一个新线程，如果线程数量已经达到maxPoolSize，则会执行拒绝策略。

  ​	LinkedBlockingQuene：基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。由于该队列的近似无界性，	当线程池中线程数量达到corePoolSize后，再有新任务进来，会一直存入该队列，而不会去创建新线程直到maxPoolSize，因此使	用该工作队列时，参数maxPoolSize其实是不起作用的。

  ​	SynchronousQuene：一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，	不会缓存，而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到maxPoolSize，则执行拒绝策略。

  ​	PriorityBlockingQueue：具有优先级的无界阻塞队列，优先级通过参数Comparator实现。

- **threadFactory**：创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon（守护）线程等等。

- **handler**：拒绝策略。当工作队列中的任务已到达最大限制，并且线程池中的线程数量也达到最大限制，这时如果有新任务提交进来，就会执行拒绝策略。JDK中提供了四种拒绝策略：

  ​	CallerRunsPolicy：该策略下，在调用者线程中直接执行被拒绝任务的run方法，除非线程池已经shutdown，则直接抛弃任务。

  ​	AbortPolicy：该策略下，直接丢弃任务，并抛出RejectedExecutionException异常。

  ​	DiscardPolicy：该策略下，直接丢弃任务，什么都不做。

  ​	DiscardOldestPolicy：该策略下，抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列。

## 线程池的执行流程

线程池执行任务，首先判断核心线程是否已满，如果未满，创建核心线程来执行；如果已满则放入任务队列，任务队列也已满的话看该线程池中是否达到了最大线程数，如果没有达到则创建临时线程去执行，达到了的话就执行拒绝策略。
